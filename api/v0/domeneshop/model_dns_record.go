/*
 * Domeneshop API Documentation
 *
 * # Overview  Domeneshop offers a simple, REST-based API, which currently supports the following features:  - List domains - List invoices - Create, read, update and delete DNS records for domains - Create, read, update and delete HTTP forwards (\"WWW forwarding\") for domains - Dynamic DNS (DDNS) update endpoints for use in consumer routers  More features are planned, including:  - Web hosting administration - Email address and email user/account administration  # Testing period  The API service is in version 0, which means it is possible that the interface will change rapidly during the testing period. For that reason, **the documentation on these pages may sometimes be outdated.**  Additionally, we make no guarantees about the stability of the API service during this testing period, and therefore ask customers to be careful with using the service for business critical purposes.  # Authentication  The Domeneshop API currently supports only one method of authentication, **HTTP Basic Auth**. More authentication methods may be added in the future.  To generate credentials, visit <a href=\"https://www.domeneshop.no/admin?view=api\" target=\"_blank\">this page</a> after logging in to the control panel on our website:  <a href=\"https://www.domeneshop.no/admin?view=api\" target=\"_blank\">https://www.domeneshop.no/admin?view=api</a>  # Libraries  Domeneshop maintains multiple API libraries to simplify using the API. Please note that these libraries have the same stability guarantees to the API while the API is in version 0.  The libraries may be found in our [Github repository](https://github.com/domeneshop/).  Domeneshop also maintains a plugin for [EFF's Certbot](https://certbot.eff.org/), which automates issuance and renewal of SSL-certificates on your own servers for domains that use Domeneshop's DNS service. This plugin is found in our Github repository [here](https://github.com/domeneshop/certbot-dns-domeneshop).  <SecurityDefinitions /> 
 *
 * API version: v0
 * Contact: kundeservice@domeneshop.no
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package domeneshop

import (
	"encoding/json"
	"fmt"
)

// DNSRecord - struct for DNSRecord
type DNSRecord struct {
	A *A
	AAAA *AAAA
	ANAME *ANAME
	CAA *CAA
	CNAME *CNAME
	DS *DS
	MX *MX
	NS *NS
	SRV *SRV
	TLSA *TLSA
	TXT *TXT
}

// AAsDNSRecord is a convenience function that returns A wrapped in DNSRecord
func AAsDNSRecord(v *A) DNSRecord {
	return DNSRecord{ A: v}
}

// AAAAAsDNSRecord is a convenience function that returns AAAA wrapped in DNSRecord
func AAAAAsDNSRecord(v *AAAA) DNSRecord {
	return DNSRecord{ AAAA: v}
}

// ANAMEAsDNSRecord is a convenience function that returns ANAME wrapped in DNSRecord
func ANAMEAsDNSRecord(v *ANAME) DNSRecord {
	return DNSRecord{ ANAME: v}
}

// CAAAsDNSRecord is a convenience function that returns CAA wrapped in DNSRecord
func CAAAsDNSRecord(v *CAA) DNSRecord {
	return DNSRecord{ CAA: v}
}

// CNAMEAsDNSRecord is a convenience function that returns CNAME wrapped in DNSRecord
func CNAMEAsDNSRecord(v *CNAME) DNSRecord {
	return DNSRecord{ CNAME: v}
}

// DSAsDNSRecord is a convenience function that returns DS wrapped in DNSRecord
func DSAsDNSRecord(v *DS) DNSRecord {
	return DNSRecord{ DS: v}
}

// MXAsDNSRecord is a convenience function that returns MX wrapped in DNSRecord
func MXAsDNSRecord(v *MX) DNSRecord {
	return DNSRecord{ MX: v}
}

// NSAsDNSRecord is a convenience function that returns NS wrapped in DNSRecord
func NSAsDNSRecord(v *NS) DNSRecord {
	return DNSRecord{ NS: v}
}

// SRVAsDNSRecord is a convenience function that returns SRV wrapped in DNSRecord
func SRVAsDNSRecord(v *SRV) DNSRecord {
	return DNSRecord{ SRV: v}
}

// TLSAAsDNSRecord is a convenience function that returns TLSA wrapped in DNSRecord
func TLSAAsDNSRecord(v *TLSA) DNSRecord {
	return DNSRecord{ TLSA: v}
}

// TXTAsDNSRecord is a convenience function that returns TXT wrapped in DNSRecord
func TXTAsDNSRecord(v *TXT) DNSRecord {
	return DNSRecord{ TXT: v}
}


// Unmarshal JSON data into one of the pointers in the struct
func (dst *DNSRecord) UnmarshalJSON(data []byte) error {
	var err error
	// use discriminator value to speed up the lookup
	var jsonDict map[string]interface{}
	err = json.Unmarshal(data, &jsonDict)
	if err != nil {
		return fmt.Errorf("Failed to unmarshal JSON into map for the discrimintor lookup.")
	}

	// check if the discriminator value is 'A'
	if jsonDict["type"] == "A" {
		// try to unmarshal JSON data into A
		err = json.Unmarshal(data, &dst.A)
		if err == nil {
			return nil // data stored in dst.A, return on the first match
		} else {
			dst.A = nil
			return fmt.Errorf("Failed to unmarshal DNSRecord as A: %s", err.Error())
		}
	}

	// check if the discriminator value is 'AAAA'
	if jsonDict["type"] == "AAAA" {
		// try to unmarshal JSON data into AAAA
		err = json.Unmarshal(data, &dst.AAAA)
		if err == nil {
			return nil // data stored in dst.AAAA, return on the first match
		} else {
			dst.AAAA = nil
			return fmt.Errorf("Failed to unmarshal DNSRecord as AAAA: %s", err.Error())
		}
	}

	// check if the discriminator value is 'ANAME'
	if jsonDict["type"] == "ANAME" {
		// try to unmarshal JSON data into ANAME
		err = json.Unmarshal(data, &dst.ANAME)
		if err == nil {
			return nil // data stored in dst.ANAME, return on the first match
		} else {
			dst.ANAME = nil
			return fmt.Errorf("Failed to unmarshal DNSRecord as ANAME: %s", err.Error())
		}
	}

	// check if the discriminator value is 'CAA'
	if jsonDict["type"] == "CAA" {
		// try to unmarshal JSON data into CAA
		err = json.Unmarshal(data, &dst.CAA)
		if err == nil {
			return nil // data stored in dst.CAA, return on the first match
		} else {
			dst.CAA = nil
			return fmt.Errorf("Failed to unmarshal DNSRecord as CAA: %s", err.Error())
		}
	}

	// check if the discriminator value is 'CNAME'
	if jsonDict["type"] == "CNAME" {
		// try to unmarshal JSON data into CNAME
		err = json.Unmarshal(data, &dst.CNAME)
		if err == nil {
			return nil // data stored in dst.CNAME, return on the first match
		} else {
			dst.CNAME = nil
			return fmt.Errorf("Failed to unmarshal DNSRecord as CNAME: %s", err.Error())
		}
	}

	// check if the discriminator value is 'DS'
	if jsonDict["type"] == "DS" {
		// try to unmarshal JSON data into DS
		err = json.Unmarshal(data, &dst.DS)
		if err == nil {
			return nil // data stored in dst.DS, return on the first match
		} else {
			dst.DS = nil
			return fmt.Errorf("Failed to unmarshal DNSRecord as DS: %s", err.Error())
		}
	}

	// check if the discriminator value is 'MX'
	if jsonDict["type"] == "MX" {
		// try to unmarshal JSON data into MX
		err = json.Unmarshal(data, &dst.MX)
		if err == nil {
			return nil // data stored in dst.MX, return on the first match
		} else {
			dst.MX = nil
			return fmt.Errorf("Failed to unmarshal DNSRecord as MX: %s", err.Error())
		}
	}

	// check if the discriminator value is 'NS'
	if jsonDict["type"] == "NS" {
		// try to unmarshal JSON data into NS
		err = json.Unmarshal(data, &dst.NS)
		if err == nil {
			return nil // data stored in dst.NS, return on the first match
		} else {
			dst.NS = nil
			return fmt.Errorf("Failed to unmarshal DNSRecord as NS: %s", err.Error())
		}
	}

	// check if the discriminator value is 'SRV'
	if jsonDict["type"] == "SRV" {
		// try to unmarshal JSON data into SRV
		err = json.Unmarshal(data, &dst.SRV)
		if err == nil {
			return nil // data stored in dst.SRV, return on the first match
		} else {
			dst.SRV = nil
			return fmt.Errorf("Failed to unmarshal DNSRecord as SRV: %s", err.Error())
		}
	}

	// check if the discriminator value is 'TLSA'
	if jsonDict["type"] == "TLSA" {
		// try to unmarshal JSON data into TLSA
		err = json.Unmarshal(data, &dst.TLSA)
		if err == nil {
			return nil // data stored in dst.TLSA, return on the first match
		} else {
			dst.TLSA = nil
			return fmt.Errorf("Failed to unmarshal DNSRecord as TLSA: %s", err.Error())
		}
	}

	// check if the discriminator value is 'TXT'
	if jsonDict["type"] == "TXT" {
		// try to unmarshal JSON data into TXT
		err = json.Unmarshal(data, &dst.TXT)
		if err == nil {
			return nil // data stored in dst.TXT, return on the first match
		} else {
			dst.TXT = nil
			return fmt.Errorf("Failed to unmarshal DNSRecord as TXT: %s", err.Error())
		}
	}

	return nil
}

// Marshal data from the first non-nil pointers in the struct to JSON
func (src DNSRecord) MarshalJSON() ([]byte, error) {
	if src.A != nil {
		return json.Marshal(&src.A)
	}

	if src.AAAA != nil {
		return json.Marshal(&src.AAAA)
	}

	if src.ANAME != nil {
		return json.Marshal(&src.ANAME)
	}

	if src.CAA != nil {
		return json.Marshal(&src.CAA)
	}

	if src.CNAME != nil {
		return json.Marshal(&src.CNAME)
	}

	if src.DS != nil {
		return json.Marshal(&src.DS)
	}

	if src.MX != nil {
		return json.Marshal(&src.MX)
	}

	if src.NS != nil {
		return json.Marshal(&src.NS)
	}

	if src.SRV != nil {
		return json.Marshal(&src.SRV)
	}

	if src.TLSA != nil {
		return json.Marshal(&src.TLSA)
	}

	if src.TXT != nil {
		return json.Marshal(&src.TXT)
	}

	return nil, nil // no data in oneOf schemas
}

// Get the actual instance
func (obj *DNSRecord) GetActualInstance() (interface{}) {
	if obj.A != nil {
		return obj.A
	}

	if obj.AAAA != nil {
		return obj.AAAA
	}

	if obj.ANAME != nil {
		return obj.ANAME
	}

	if obj.CAA != nil {
		return obj.CAA
	}

	if obj.CNAME != nil {
		return obj.CNAME
	}

	if obj.DS != nil {
		return obj.DS
	}

	if obj.MX != nil {
		return obj.MX
	}

	if obj.NS != nil {
		return obj.NS
	}

	if obj.SRV != nil {
		return obj.SRV
	}

	if obj.TLSA != nil {
		return obj.TLSA
	}

	if obj.TXT != nil {
		return obj.TXT
	}

	// all schemas are nil
	return nil
}

type NullableDNSRecord struct {
	value *DNSRecord
	isSet bool
}

func (v NullableDNSRecord) Get() *DNSRecord {
	return v.value
}

func (v *NullableDNSRecord) Set(val *DNSRecord) {
	v.value = val
	v.isSet = true
}

func (v NullableDNSRecord) IsSet() bool {
	return v.isSet
}

func (v *NullableDNSRecord) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableDNSRecord(val *DNSRecord) *NullableDNSRecord {
	return &NullableDNSRecord{value: val, isSet: true}
}

func (v NullableDNSRecord) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableDNSRecord) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


