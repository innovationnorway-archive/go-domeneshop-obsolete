/*
 * Domeneshop API Documentation
 *
 * # Overview  Domeneshop offers a simple, REST-based API, which currently supports the following features:  - List domains - List invoices - Create, read, update and delete DNS records for domains - Create, read, update and delete HTTP forwards (\"WWW forwarding\") for domains - Dynamic DNS (DDNS) update endpoints for use in consumer routers  More features are planned, including:  - Web hosting administration - Email address and email user/account administration  # Testing period  The API service is in version 0, which means it is possible that the interface will change rapidly during the testing period. For that reason, **the documentation on these pages may sometimes be outdated.**  Additionally, we make no guarantees about the stability of the API service during this testing period, and therefore ask customers to be careful with using the service for business critical purposes.  # Authentication  The Domeneshop API currently supports only one method of authentication, **HTTP Basic Auth**. More authentication methods may be added in the future.  To generate credentials, visit <a href=\"https://www.domeneshop.no/admin?view=api\" target=\"_blank\">this page</a> after logging in to the control panel on our website:  <a href=\"https://www.domeneshop.no/admin?view=api\" target=\"_blank\">https://www.domeneshop.no/admin?view=api</a>  # Libraries  Domeneshop maintains multiple API libraries to simplify using the API. Please note that these libraries have the same stability guarantees to the API while the API is in version 0.  The libraries may be found in our [Github repository](https://github.com/domeneshop/).  Domeneshop also maintains a plugin for [EFF's Certbot](https://certbot.eff.org/), which automates issuance and renewal of SSL-certificates on your own servers for domains that use Domeneshop's DNS service. This plugin is found in our Github repository [here](https://github.com/domeneshop/certbot-dns-domeneshop).  <SecurityDefinitions /> 
 *
 * API version: v0
 * Contact: kundeservice@domeneshop.no
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package domeneshop

import (
	"encoding/json"
	"fmt"
)

// DNSRecord - struct for DNSRecord
type DNSRecord struct {
	A *A
	AAAA *AAAA
	CNAME *CNAME
	MX *MX
	SRV *SRV
	TXT *TXT
}

// AAsDNSRecord is a convenience function that returns A wrapped in DNSRecord
func AAsDNSRecord(v *A) DNSRecord {
	return DNSRecord{ A: v}
}

// AAAAAsDNSRecord is a convenience function that returns AAAA wrapped in DNSRecord
func AAAAAsDNSRecord(v *AAAA) DNSRecord {
	return DNSRecord{ AAAA: v}
}

// CNAMEAsDNSRecord is a convenience function that returns CNAME wrapped in DNSRecord
func CNAMEAsDNSRecord(v *CNAME) DNSRecord {
	return DNSRecord{ CNAME: v}
}

// MXAsDNSRecord is a convenience function that returns MX wrapped in DNSRecord
func MXAsDNSRecord(v *MX) DNSRecord {
	return DNSRecord{ MX: v}
}

// SRVAsDNSRecord is a convenience function that returns SRV wrapped in DNSRecord
func SRVAsDNSRecord(v *SRV) DNSRecord {
	return DNSRecord{ SRV: v}
}

// TXTAsDNSRecord is a convenience function that returns TXT wrapped in DNSRecord
func TXTAsDNSRecord(v *TXT) DNSRecord {
	return DNSRecord{ TXT: v}
}


// Unmarshal JSON data into one of the pointers in the struct
func (dst *DNSRecord) UnmarshalJSON(data []byte) error {
	var err error
	match := 0
	// try to unmarshal data into A
	err = json.Unmarshal(data, &dst.A)
	if err == nil {
		jsonA, _ := json.Marshal(dst.A)
		if string(jsonA) == "{}" { // empty struct
			dst.A = nil
		} else {
			match++
		}
	} else {
		dst.A = nil
	}

	// try to unmarshal data into AAAA
	err = json.Unmarshal(data, &dst.AAAA)
	if err == nil {
		jsonAAAA, _ := json.Marshal(dst.AAAA)
		if string(jsonAAAA) == "{}" { // empty struct
			dst.AAAA = nil
		} else {
			match++
		}
	} else {
		dst.AAAA = nil
	}

	// try to unmarshal data into CNAME
	err = json.Unmarshal(data, &dst.CNAME)
	if err == nil {
		jsonCNAME, _ := json.Marshal(dst.CNAME)
		if string(jsonCNAME) == "{}" { // empty struct
			dst.CNAME = nil
		} else {
			match++
		}
	} else {
		dst.CNAME = nil
	}

	// try to unmarshal data into MX
	err = json.Unmarshal(data, &dst.MX)
	if err == nil {
		jsonMX, _ := json.Marshal(dst.MX)
		if string(jsonMX) == "{}" { // empty struct
			dst.MX = nil
		} else {
			match++
		}
	} else {
		dst.MX = nil
	}

	// try to unmarshal data into SRV
	err = json.Unmarshal(data, &dst.SRV)
	if err == nil {
		jsonSRV, _ := json.Marshal(dst.SRV)
		if string(jsonSRV) == "{}" { // empty struct
			dst.SRV = nil
		} else {
			match++
		}
	} else {
		dst.SRV = nil
	}

	// try to unmarshal data into TXT
	err = json.Unmarshal(data, &dst.TXT)
	if err == nil {
		jsonTXT, _ := json.Marshal(dst.TXT)
		if string(jsonTXT) == "{}" { // empty struct
			dst.TXT = nil
		} else {
			match++
		}
	} else {
		dst.TXT = nil
	}

	if match > 1 { // more than 1 match
		// reset to nil
		dst.A = nil
		dst.AAAA = nil
		dst.CNAME = nil
		dst.MX = nil
		dst.SRV = nil
		dst.TXT = nil

		return fmt.Errorf("Data matches more than one schema in oneOf(DNSRecord)")
	} else if match == 1 {
		return nil // exactly one match
	} else { // no match
		return fmt.Errorf("Data failed to match schemas in oneOf(DNSRecord)")
	}
}

// Marshal data from the first non-nil pointers in the struct to JSON
func (src DNSRecord) MarshalJSON() ([]byte, error) {
	if src.A != nil {
		return json.Marshal(&src.A)
	}

	if src.AAAA != nil {
		return json.Marshal(&src.AAAA)
	}

	if src.CNAME != nil {
		return json.Marshal(&src.CNAME)
	}

	if src.MX != nil {
		return json.Marshal(&src.MX)
	}

	if src.SRV != nil {
		return json.Marshal(&src.SRV)
	}

	if src.TXT != nil {
		return json.Marshal(&src.TXT)
	}

	return nil, nil // no data in oneOf schemas
}

// Get the actual instance
func (obj *DNSRecord) GetActualInstance() (interface{}) {
	if obj.A != nil {
		return obj.A
	}

	if obj.AAAA != nil {
		return obj.AAAA
	}

	if obj.CNAME != nil {
		return obj.CNAME
	}

	if obj.MX != nil {
		return obj.MX
	}

	if obj.SRV != nil {
		return obj.SRV
	}

	if obj.TXT != nil {
		return obj.TXT
	}

	// all schemas are nil
	return nil
}

type NullableDNSRecord struct {
	value *DNSRecord
	isSet bool
}

func (v NullableDNSRecord) Get() *DNSRecord {
	return v.value
}

func (v *NullableDNSRecord) Set(val *DNSRecord) {
	v.value = val
	v.isSet = true
}

func (v NullableDNSRecord) IsSet() bool {
	return v.isSet
}

func (v *NullableDNSRecord) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableDNSRecord(val *DNSRecord) *NullableDNSRecord {
	return &NullableDNSRecord{value: val, isSet: true}
}

func (v NullableDNSRecord) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableDNSRecord) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


